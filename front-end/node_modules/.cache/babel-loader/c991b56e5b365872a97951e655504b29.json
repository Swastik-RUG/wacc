{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar d3 = _interopRequireWildcard(require(\"d3\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nrequire(\"./style.css\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n\n  if (obj != null) {\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/*\r\nGaugeChart creates a gauge chart using D3\r\nThe chart is responsive and will have the same width as the \"container\"\r\nThe radius of the gauge depends on the width and height of the container\r\nIt will use whichever is smallest of width or height\r\nThe svg element surrounding the gauge will always be square\r\n\"container\" is the div where the chart should be placed\r\n*/\n//Constants\n\n\nvar startAngle = -Math.PI / 2; //Negative x-axis\n\nvar endAngle = Math.PI / 2; //Positive x-axis\n// Props that should cause an animation on update\n\nvar animateNeedleProps = ['marginInPercent', 'arcPadding', 'percent', 'nrOfLevels'];\n\nvar GaugeChart =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(GaugeChart, _React$Component);\n\n  function GaugeChart(props) {\n    var _this;\n\n    _classCallCheck(this, GaugeChart);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GaugeChart).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"initChart\", function (update) {\n      var resize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (update) {\n        _this.renderChart(resize);\n\n        return;\n      }\n\n      _this.svg = _this.container.append('svg');\n      _this.g = _this.svg.append('g'); //Used for margins\n\n      _this.doughnut = _this.g.append('g').attr('class', 'doughnut'); //Set up the pie generator\n      //Each arc should be of equal length (or should they?)\n\n      _this.pie.value(function (d) {\n        return d.value;\n      }) //.padAngle(arcPadding)\n      .startAngle(startAngle).endAngle(endAngle).sort(null); //Add the needle element\n\n\n      _this.needle = _this.g.append('g').attr('class', 'needle'); //Set up resize event listener to re-render the chart everytime the window is resized\n\n      window.addEventListener('resize', function () {\n        var resize = true;\n\n        _this.renderChart(resize);\n      });\n\n      _this.renderChart(resize);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"renderChart\", function (resize) {\n      _this.updateDimensions(); //Set dimensions of svg element and translations\n\n\n      _this.svg.attr('width', _this.width + _this.margin.left + _this.margin.right).attr('height', _this.height + _this.margin.top + _this.margin.bottom);\n\n      _this.g.attr('transform', 'translate(' + _this.margin.left + ', ' + _this.margin.top + ')'); //Set the radius to lesser of width or height and remove the margins\n      //Calculate the new radius\n\n\n      _this.calculateRadius();\n\n      _this.doughnut.attr('transform', 'translate(' + _this.outerRadius + ', ' + _this.outerRadius + ')'); //Setup the arc\n\n\n      _this.arc.outerRadius(_this.outerRadius).innerRadius(_this.outerRadius * (1 - _this.props.arcWidth)).cornerRadius(_this.props.cornerRadius).padAngle(_this.props.arcPadding); //Remove the old stuff\n\n\n      _this.doughnut.selectAll('.arc').remove();\n\n      _this.needle.selectAll('*').remove();\n\n      _this.g.selectAll('.text-group').remove(); //Draw the arc\n\n\n      var arcPaths = _this.doughnut.selectAll('.arc').data(_this.pie(_this.arcData)).enter().append('g').attr('class', 'arc');\n\n      arcPaths.append('path').attr('d', _this.arc).style('fill', function (d) {\n        return d.data.color;\n      });\n\n      _this.drawNeedle(resize); //Translate the needle starting point to the middle of the arc\n\n\n      _this.needle.attr('transform', 'translate(' + _this.outerRadius + ', ' + _this.outerRadius + ')');\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"updateDimensions\", function () {\n      //TODO: Fix so that the container is included in the component\n      var marginInPercent = _this.props.marginInPercent;\n\n      var divDimensions = _this.container.node().getBoundingClientRect(),\n          divWidth = divDimensions.width,\n          divHeight = divDimensions.height; //Set the new width and horizontal margins\n\n\n      _this.margin.left = divWidth * marginInPercent;\n      _this.margin.right = divWidth * marginInPercent;\n      _this.width = divWidth - _this.margin.left - _this.margin.right;\n      _this.margin.top = divHeight * marginInPercent;\n      _this.margin.bottom = divHeight * marginInPercent;\n      _this.height = _this.width / 2 - _this.margin.top - _this.margin.bottom; //this.height = divHeight - this.margin.top - this.margin.bottom;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"calculateRadius\", function () {\n      //The radius needs to be constrained by the containing div\n      //Since it is a half circle we are dealing with the height of the div\n      //Only needs to be half of the width, because the width needs to be 2 * radius\n      //For the whole arc to fit\n      //First check if it is the width or the height that is the \"limiting\" dimension\n      if (_this.width < 2 * _this.height) {\n        //Then the width limits the size of the chart\n        //Set the radius to the width - the horizontal margins\n        _this.outerRadius = (_this.width - _this.margin.left - _this.margin.right) / 2;\n      } else {\n        _this.outerRadius = _this.height - _this.margin.top - _this.margin.bottom;\n      }\n\n      _this.centerGraph();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"centerGraph\", function () {\n      _this.margin.left = _this.width / 2 - _this.outerRadius + _this.margin.right;\n\n      _this.g.attr('transform', 'translate(' + _this.margin.left + ', ' + _this.margin.top + ')');\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"drawNeedle\", function (resize) {\n      var _this$props = _this.props,\n          percent = _this$props.percent,\n          needleColor = _this$props.needleColor,\n          needleBaseColor = _this$props.needleBaseColor,\n          hideText = _this$props.hideText,\n          animate = _this$props.animate;\n\n      var _assertThisInitialize = _assertThisInitialized(_this),\n          container = _assertThisInitialize.container,\n          calculateRotation = _assertThisInitialize.calculateRotation;\n\n      var needleRadius = 15 * (_this.width / 500),\n          // Make the needle radius responsive\n      centerPoint = [0, -needleRadius / 2]; //Draw the triangle\n      //var pathStr = `M ${leftPoint[0]} ${leftPoint[1]} L ${topPoint[0]} ${topPoint[1]} L ${rightPoint[0]} ${rightPoint[1]}`;\n\n      var pathStr = _this.calculateRotation(0);\n\n      _this.needle.append('path').attr('d', pathStr).attr('fill', needleColor); //Add a circle at the bottom of needle\n\n\n      _this.needle.append('circle').attr('cx', centerPoint[0]).attr('cy', centerPoint[1]).attr('r', needleRadius).attr('fill', needleBaseColor);\n\n      if (!hideText) {\n        _this.addText(percent);\n      } //Rotate the needle\n\n\n      if (!resize && animate) {\n        _this.needle.transition().delay(500).ease(d3.easeElastic).duration(3000).tween('progress', function () {\n          return function (percentOfPercent) {\n            var progress = percentOfPercent * percent;\n            return container.select(\".needle path\").attr(\"d\", calculateRotation(progress));\n          };\n        });\n      } else {\n        container.select(\".needle path\").attr(\"d\", calculateRotation(percent));\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"calculateRotation\", function (percent) {\n      var needleLength = _this.outerRadius * 0.55,\n          //TODO: Maybe it should be specified as a percentage of the arc radius?\n      needleRadius = 15 * (_this.width / 500),\n          theta = _this.percentToRad(percent),\n          centerPoint = [0, -needleRadius / 2],\n          topPoint = [centerPoint[0] - needleLength * Math.cos(theta), centerPoint[1] - needleLength * Math.sin(theta)],\n          leftPoint = [centerPoint[0] - needleRadius * Math.cos(theta - Math.PI / 2), centerPoint[1] - needleRadius * Math.sin(theta - Math.PI / 2)],\n          rightPoint = [centerPoint[0] - needleRadius * Math.cos(theta + Math.PI / 2), centerPoint[1] - needleRadius * Math.sin(theta + Math.PI / 2)];\n\n      var pathStr = \"M \".concat(leftPoint[0], \" \").concat(leftPoint[1], \" L \").concat(topPoint[0], \" \").concat(topPoint[1], \" L \").concat(rightPoint[0], \" \").concat(rightPoint[1]);\n      return pathStr;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"percentToRad\", function (percent) {\n      return percent * Math.PI;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getColors\", function () {\n      var colors = _this.props.colors;\n      var colorScale = d3.scaleLinear().domain([1, _this.nbArcsToDisplay]).range([colors[0], colors[colors.length - 1]]) //Use the first and the last color as range\n      .interpolate(d3.interpolateHsl);\n      var colorArray = [];\n\n      for (var i = 1; i <= _this.nbArcsToDisplay; i++) {\n        colorArray.push(colorScale(i));\n      }\n\n      return colorArray;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"addText\", function (percentage) {\n      var textPadding = 20;\n\n      _this.g.append('g').attr('class', 'text-group').attr('transform', \"translate(\".concat(_this.outerRadius, \", \").concat(_this.outerRadius / 2 + textPadding, \")\")).append('text').text(\"\".concat(_this.floatingNumber(percentage), \"%\")).style('font-size', function () {\n        return \"\".concat(_this.width / 10, \"px\");\n      }).style('fill', _this.props.textColor).attr('class', 'percent-text');\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"floatingNumber\", function (value) {\n      var maxDigits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      return Math.round(value * 100 * Math.pow(10, maxDigits)) / Math.pow(10, maxDigits);\n    });\n\n    var _this$props2 = _this.props,\n        nrOfLevels = _this$props2.nrOfLevels,\n        _colors = _this$props2.colors; //Class variables\n\n    _this.svg = {};\n    _this.g = {};\n    _this.width = {};\n    _this.height = {};\n    _this.doughnut = {};\n    _this.needle = {};\n    _this.data = {};\n    _this.outerRadius = {};\n    _this.margin = {}; // = {top: 20, right: 50, bottom: 50, left: 50},\n\n    _this.arc = d3.arc();\n    _this.pie = d3.pie(); // We have to make a decision about number of arcs to display\n    // If arcsLength is setted, we choose arcsLength length instead of nrOfLevels\n\n    _this.nbArcsToDisplay = props.arcsLength ? props.arcsLength.length : nrOfLevels; //Check if the number of colors equals the number of levels\n    //Otherwise make an interpolation\n\n    if (_this.nbArcsToDisplay === _colors.length) {\n      _this.colorArray = _colors;\n    } else {\n      _this.colorArray = _this.getColors();\n    } //The data that is used to create the arc\n    // Each arc could have hiw own value width arcsLength prop\n\n\n    _this.arcData = [];\n\n    for (var _i = 0; _i < _this.nbArcsToDisplay; _i++) {\n      var arcDatum = {\n        value: props.arcsLength && props.arcsLength.length > _i ? props.arcsLength[_i] : 1,\n        color: _this.colorArray[_i]\n      };\n\n      _this.arcData.push(arcDatum);\n    }\n\n    return _this;\n  }\n\n  _createClass(GaugeChart, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.id) {\n        this.container = d3.select(\"#\".concat(this.props.id)); //Initialize chart\n\n        this.initChart();\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this2 = this; //Initialize chart\n      // Always redraw the chart, but potentially do not animate it\n\n\n      var resize = !animateNeedleProps.some(function (key) {\n        return prevProps[key] !== _this2.props[key];\n      });\n      this.initChart(true, resize);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return _react.default.createElement(\"div\", {\n        id: this.props.id,\n        style: {\n          width: '100%'\n        }\n      });\n    }\n  }]);\n\n  return GaugeChart;\n}(_react.default.Component);\n\nvar _default = GaugeChart;\nexports.default = _default;\nGaugeChart.defaultProps = {\n  marginInPercent: 0.05,\n  cornerRadius: 6,\n  nrOfLevels: 3,\n  percent: 0.4,\n  arcPadding: 0.05,\n  //The padding between arcs, in rad\n  arcWidth: 0.2,\n  //The width of the arc given in percent of the radius\n  colors: ['#00FF00', '#FF0000'],\n  //Default defined colors\n  textColor: '#fff',\n  needleColor: \"#464A4F\",\n  needleBaseColor: \"#464A4F\",\n  hideText: false,\n  animate: true\n};\nGaugeChart.propTypes = {\n  id: _propTypes.default.string.isRequired,\n  marginInPercent: _propTypes.default.number,\n  cornerRadius: _propTypes.default.number,\n  nrOfLevels: _propTypes.default.number,\n  percent: _propTypes.default.number,\n  arcPadding: _propTypes.default.number,\n  arcWidth: _propTypes.default.number,\n  arcsLength: _propTypes.default.array,\n  colors: _propTypes.default.array,\n  textColor: _propTypes.default.string,\n  needleColor: _propTypes.default.string,\n  needleBaseColor: _propTypes.default.string,\n  hideText: _propTypes.default.bool,\n  animate: _propTypes.default.bool\n};","map":null,"metadata":{},"sourceType":"script"}